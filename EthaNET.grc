options:
  parameters:
    author: brian
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: gnuFlow
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: alpha
  id: variable
  parameters:
    comment: 'Can''t change alpha in real time

      for Consteallation Modulator'
    value: '0.9'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 92.0]
    rotation: 0
    state: enabled
- name: center_freq
  id: variable
  parameters:
    comment: ''
    value: 915e6
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [312, 12.0]
    rotation: 0
    state: enabled
- name: constellation
  id: variable_constellation
  parameters:
    comment: ''
    const_points: '[-1-1j, -1+1j, 1+1j, 1-1j]'
    dims: '1'
    normalization: digital.constellation.AMPLITUDE_NORMALIZATION
    npwr: '1.0'
    precision: '8'
    rot_sym: '4'
    soft_dec_lut: None
    sym_map: '[0, 1, 3, 2]'
    type: bpsk
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [520, 12.0]
    rotation: 0
    state: enabled
- name: constellation1
  id: variable_constellation
  parameters:
    comment: ''
    const_points: '[-1-1j, -1+1j, 1+1j, 1-1j]'
    dims: '1'
    normalization: digital.constellation.AMPLITUDE_NORMALIZATION
    npwr: '1.0'
    precision: '8'
    rot_sym: '4'
    soft_dec_lut: None
    sym_map: '[0, 1, 3, 2]'
    type: qpsk
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [680, 16.0]
    rotation: 0
    state: enabled
- name: costas_loop_bandwidth_in_cycles_per_sample
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: 21,0
    label: ''
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0.0001'
    step: '0.0001'
    stop: '0.2'
    value: '.01'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [632, 2032.0]
    rotation: 0
    state: disabled
- name: nfilts
  id: variable
  parameters:
    comment: ''
    value: '32'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [384, 2184.0]
    rotation: 0
    state: disabled
- name: offset
  id: variable_qtgui_range
  parameters:
    comment: increased range with FLL
    gui_hint: 6,0
    label: ''
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: -500e3
    step: '1'
    stop: 500e3
    value: '0'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [144, 1216.0]
    rotation: 0
    state: disabled
- name: output_sps
  id: variable
  parameters:
    comment: ''
    value: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [472, 2184.0]
    rotation: 0
    state: disabled
- name: rcc_taps
  id: variable_rrc_filter_taps
  parameters:
    alpha: alpha
    comment: 'Gain: nfilts

      Sample Rate: nfilts*samp_rate

      Symbol Rate: samp_rate/sps

      Excess BW: alpha

      Num Taps: 11*sps*nfilts'
    gain: nfilts
    ntaps: 11*sps*nfilts
    samp_rate: nfilts*samp_rate
    sym_rate: samp_rate/sps
    value: ''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 2184.0]
    rotation: 0
    state: disabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: 1e6
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 12.0]
    rotation: 0
    state: enabled
- name: sps
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [432, 12.0]
    rotation: 0
    state: true
- name: tx_attenuation
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: 3,0
    label: ''
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0'
    step: '1'
    stop: '89'
    value: '10'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1000, 8.0]
    rotation: 0
    state: disabled
- name: analog_agc_xx_1
  id: analog_agc_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    gain: '1.0'
    max_gain: '65536'
    maxoutbuf: '0'
    minoutbuf: '0'
    rate: 1e-4
    reference: '1.0'
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [560, 1384.0]
    rotation: 0
    state: disabled
- name: analog_random_source_x_0
  id: analog_random_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: 100 bits of random payload data
    max: '2'
    maxoutbuf: '0'
    min: '0'
    minoutbuf: '0'
    num_samps: '10000'
    repeat: 'True'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [32, 836.0]
    rotation: 0
    state: enabled
- name: analog_random_uniform_source_x_0_0_0
  id: analog_random_uniform_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: 'random bytes;

      simulates input from TX python script'
    maximum: '256'
    maxoutbuf: '0'
    minimum: '0'
    minoutbuf: '0'
    seed: '0'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [144, 1056.0]
    rotation: 0
    state: disabled
- name: analog_sig_source_x_0
  id: analog_sig_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: '1'
    comment: ''
    freq: offset
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    phase: '0'
    samp_rate: samp_rate
    showports: 'False'
    type: complex
    waveform: analog.GR_COS_WAVE
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [144, 1384.0]
    rotation: 0
    state: disabled
- name: blocks_multiply_const_vxx_0
  id: blocks_multiply_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: 'Keep the signal from going

      above +1 or below -1'
    const: '0.4'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [680, 1072.0]
    rotation: 0
    state: disabled
- name: blocks_multiply_xx_0
  id: blocks_multiply_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [408, 1408.0]
    rotation: 0
    state: disabled
- name: blocks_selector_1
  id: blocks_selector
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    enabled: 'True'
    input_index: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    num_outputs: '1'
    output_index: '0'
    showports: 'False'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [736, 232.0]
    rotation: 0
    state: disabled
- name: blocks_skiphead_0
  id: blocks_skiphead
  parameters:
    affinity: ''
    alias: ''
    comment: 'skip one second of samples

      to allow FLL to sync'
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: int(samp_rate)
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [208, 1776.0]
    rotation: 180
    state: disabled
- name: blocks_stream_mux_0
  id: blocks_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: crossing streammmsss!!!
    lengths: (48, 100)
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [288, 760.0]
    rotation: 0
    state: enabled
- name: blocks_tag_debug_0_0_1_0
  id: blocks_tag_debug
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    display: 'True'
    filter: '""'
    name: stream_output
    num_inputs: '1'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1392, 360.0]
    rotation: 0
    state: disabled
- name: blocks_tagged_stream_mux_0_0
  id: blocks_tagged_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengthtagname: packet_len
    maxoutbuf: '0'
    minoutbuf: '0'
    ninputs: '2'
    tag_preserve_head_pos: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 288.0]
    rotation: 0
    state: disabled
- name: blocks_unpacked_to_packed_xx_0
  id: blocks_unpacked_to_packed_xx
  parameters:
    affinity: ''
    alias: ''
    bits_per_chunk: '1'
    comment: ''
    endianness: gr.GR_MSB_FIRST
    maxoutbuf: '0'
    minoutbuf: '0'
    num_ports: '1'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1168, 1656.0]
    rotation: 0
    state: disabled
- name: blocks_vector_source_x_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: 'Example Header for testing

      MCS: 00000001

      LEN: 01100100 (100)

      SEQ: 00000001

      SRC: 01010101

      DES: 10101010

      CRC: 10010010'
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'True'
    tags: '[]'
    type: byte
    vector: (0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,0)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [32, 660.0]
    rotation: 0
    state: enabled
- name: digital_constellation_decoder_cb_0
  id: digital_constellation_decoder_cb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: constellation
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [896, 1664.0]
    rotation: 0
    state: disabled
- name: digital_costas_loop_cc_0
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    order: constellation.arity()
    use_snr: 'False'
    w: 2*math.pi*costas_loop_bandwidth_in_cycles_per_sample
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [640, 1888.0]
    rotation: 0
    state: disabled
- name: digital_fll_band_edge_cc_0
  id: digital_fll_band_edge_cc
  parameters:
    affinity: ''
    alias: ''
    comment: 'Samples Per Symbol: sps

      Filter Rolloff Factor: alpha

      Prototype Filter Size: sps*2+1

      Loop Bandwidth: 2*math.pi/sps/100'
    filter_size: sps*2+1
    maxoutbuf: '0'
    minoutbuf: '0'
    rolloff: alpha
    samps_per_sym: sps
    type: cc
    w: 2*math.pi/sps/100
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 1608.0]
    rotation: 180
    state: disabled
- name: digital_packet_headerparser_b_0
  id: digital_packet_headerparser_b
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    header_formatter: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1104, 1520.0]
    rotation: 0
    state: disabled
- name: digital_symbol_sync_xx_0
  id: digital_symbol_sync_xx
  parameters:
    affinity: ''
    alias: ''
    comment: "Filterbank Arms: nfilts\nPFB MF Taps: rcc_taps\nChanged Maximum Deviation\
      \ to 0.1 because \nthe clocks aren't more off than 0.1 samples per symbol"
    constellation: digital.constellation_bpsk().base()
    damping: '1.0'
    loop_bw: '0.045'
    max_dev: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    nfilters: nfilts
    osps: output_sps
    pfb_mf_taps: rcc_taps
    resamp_type: digital.IR_PFB_MF
    sps: sps
    ted_gain: '1.0'
    ted_type: digital.TED_SIGNAL_TIMES_SLOPE_ML
    type: cc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 1876.0]
    rotation: 0
    state: disabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\nimport logging\n\nclass ExtractMCS(gr.basic_block):\n\
      \    def __init__(self, selector_tag:str=\"mcs_selector\", length_tag_key:str=\"\
      packet_len\"):\n        gr.basic_block.__init__(self,\n            name=\"Extract\
      \ MCS from PDU\",\n            in_sig=None,\n            out_sig=None)\n   \
      \     \n        self.selector_tag = selector_tag\n        self.length_tag_key\
      \ = pmt.intern(length_tag_key)  # Convert key to PMT\n        \n        self.message_port_register_in(pmt.intern(\"\
      pdu_in\"))\n        self.message_port_register_out(pmt.intern(\"header_out\"\
      ))\n        self.message_port_register_out(pmt.intern(\"data_out\"))\n     \
      \   self.message_port_register_out(pmt.intern(\"mcs_out\"))\n        \n    \
      \    self.set_msg_handler(pmt.intern(\"pdu_in\"), self.handle_pdu)\n       \
      \ \n        # Setup logging\n        logging.basicConfig(level=logging.DEBUG)\n\
      \        self.logger = logging.getLogger(\"ExtractMCS\")\n\n    def handle_pdu(self,\
      \ msg):\n        if not pmt.is_pair(msg):\n            self.logger.warning(\"\
      Received malformed PDU message.\")\n            return  # Ignore malformed messages\n\
      \        \n        meta = pmt.car(msg)  # Metadata\n        data = pmt.cdr(msg)\
      \  # Payload (header + actual data)\n        \n        self.logger.debug(f\"\
      Received PDU with metadata: {meta}\")\n        \n        if pmt.is_u8vector(data):\n\
      \            data_bytes = pmt.u8vector_elements(data)\n            \n      \
      \      if len(data_bytes) >= 6:\n                mcs_value = data_bytes[0] \
      \ # First byte is MCS field\n                header = data_bytes[:6]  # First\
      \ 6 bytes as header\n                payload = data_bytes[6:]  # Remaining bytes\
      \ as payload\n                \n                self.logger.info(f\"Extracted\
      \ MCS value: {mcs_value}\")\n                self.message_port_pub(pmt.intern(\"\
      mcs_out\"), pmt.cons(pmt.PMT_NIL, pmt.from_long(mcs_value)))\n\n           \
      \     # Add length tag to metadata\n                # updated_meta = pmt.dict_add(meta,\
      \ self.length_tag_key, pmt.from_long(len(header)))\n\n                # Send\
      \ header as a separate PDU\n                header_pdu = pmt.cons(meta, pmt.init_u8vector(len(header),\
      \ header))\n                self.logger.debug(\"Sending header PDU.\")\n   \
      \             self.message_port_pub(pmt.intern(\"header_out\"), header_pdu)\n\
      \                \n                # Send payload as a separate PDU\n      \
      \          payload_pdu = pmt.cons(meta, pmt.init_u8vector(len(payload), payload))\n\
      \                self.logger.debug(\"Sending payload PDU.\")\n             \
      \   self.message_port_pub(pmt.intern(\"data_out\"), payload_pdu)\n\n       \
      \     else:\n                self.logger.warning(\"Payload is too short to contain\
      \ a valid header.\")\n        else:\n            self.logger.warning(\"Payload\
      \ is not in expected format (u8vector).\")\n"
    affinity: ''
    alias: ''
    comment: 'Takes in the PDU from python land

      and splits the header from it.

      Also sets the selector block for MCS'
    length_tag_key: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
    selector_tag: '''mcs_selector'''
  states:
    _io_cache: ('Extract MCS from PDU', 'ExtractMCS', [('selector_tag', "'mcs_selector'"),
      ('length_tag_key', "'packet_len'")], [('pdu_in', 'message', 1)], [('mcs_out',
      'message', 1), ('data_out', 'message', 1), ('header_out', 'message', 1)], '',
      ['length_tag_key', 'selector_tag'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [88, 320.0]
    rotation: 0
    state: disabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\nimport numpy as np\nfrom\
      \ gnuradio import gr\nimport pmt\nimport logging\n\nclass ExtractStream(gr.basic_block):\n\
      \    # def __init__(self, selector_tag:str=\"mcs_selector\", length_tag_key:str=\"\
      packet_len\"):\n    def __init__(self):\n        gr.basic_block.__init__(self,\n\
      \            name=\"Decode from Stream\",\n            in_sig=[np.uint8],\n\
      \            out_sig=[np.uint8])\n        \n        self.message_port_register_out(pmt.intern(\"\
      mcs_out\"))\n        self.message_port_register_out(pmt.intern(\"header_out\"\
      ))\n        self.message_port_register_out(pmt.intern(\"length_out\"))\n   \
      \     \n        # Setup logging\n        logging.basicConfig(level=logging.DEBUG)\n\
      \        self.logger = logging.getLogger(\"ExtractStream\")\n        self.logger.debug(\"\
      ExtractStream block initialized.\")\n\n    def work(self, input_items, output_items):\n\
      \        in_data = input_items[0]\n        out_data = output_items[0]\n\n  \
      \      self._bit_buffer = getattr(self, \"_bit_buffer\", [])\n        self._sample_offset\
      \ = getattr(self, \"_sample_offset\", self.nitems_written(0))\n\n        # Copy\
      \ input to output\n        out_data[:len(in_data)] = in_data\n\n        for\
      \ i, bit in enumerate(in_data):\n            self._bit_buffer.append(bit & 0x01)\n\
      \            self.logger.debug(\"Bit buffer: %s\", self._bit_buffer)\n\n   \
      \         if len(self._bit_buffer) >= 48:\n                byte_list = []\n\
      \                for j in range(0, 48, 8):\n                    byte = sum((self._bit_buffer[j\
      \ + k] << (7 - k)) for k in range(8))\n                    byte_list.append(byte)\n\
      \n                header = bytearray(byte_list[:6])\n                mcs, length\
      \ = header[0], header[1]\n\n                # Publish PMT messages\n       \
      \         self.message_port_pub(pmt.intern(\"mcs_out\"), pmt.from_long(mcs))\n\
      \                self.message_port_pub(pmt.intern(\"header_out\"), pmt.init_u8vector(6,\
      \ header))\n                self.message_port_pub(pmt.intern(\"length_out\"\
      ), pmt.from_long(length))\n\n                # Tag stream\n                tag_offset\
      \ = self._sample_offset + i - 47  # Start of 48-bit sequence\n             \
      \   self.add_item_tag(0, tag_offset, pmt.intern(\"mcs_selector\"), pmt.from_long(mcs))\n\
      \                self.add_item_tag(0, tag_offset, pmt.intern(\"packet_len\"\
      ), pmt.from_long(length))\n\n                del self._bit_buffer[:48]\n\n \
      \       self._sample_offset += len(in_data)\n        return len(in_data)\n\n\
      \        \n        "
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Decode from Stream', 'ExtractStream', [], [('0', 'byte', 1)], [('0',
      'byte', 1), ('length_out', 'message', 1), ('header_out', 'message', 1), ('mcs_out',
      'message', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [520, 728.0]
    rotation: 0
    state: enabled
- name: epy_block_3
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr, blocks, digital\n\
      from gnuradio.filter import firdes\nimport pmt\n\nclass pdu_modulator(gr.basic_block):\n\
      \    \"\"\"\n    Custom GNU Radio block that takes in a PDU of bytes, maps them\
      \ to symbols,\n    applies RRC pulse shaping, and outputs a tagged complex stream.\n\
      \    \"\"\"\n    def __init__(self, constellation=digital.bpsk_constellation(),\
      \ sps=4, alpha=0.5, span=12,keep_front_transients=False,keep_back_transients=False):\n\
      \        gr.sync_block.__init__(self,\n            name=\"pdu_modulator\",\n\
      \            in_sig=None,\n            out_sig=[np.complex64])\n        \n \
      \       self.constellation = constellation\n        self.sps = sps  # Samples\
      \ per symbol\n        self.span =span\n        self.rrc_taps = firdes.root_raised_cosine(sps,\
      \ sps, 1.0, alpha, span * sps)\n        self.keep_front_transients = keep_front_transients\n\
      \        self.keep_back_transients = keep_back_transients\n        \n      \
      \  self.set_tag_propagation_policy(gr.TPP_DONT)\n        \n        self.bits_per_symbol\
      \ = int(np.log2(len(self.constellation.points())))\n\n        self.message_port_register_in(pmt.intern(\"\
      Data in\"))\n        self.set_msg_handler(pmt.intern(\"Data in\"), self.handle_pdu)\n\
      \        self.shaped_data = None\n\n    @staticmethod\n    def bits_to_decimal(bits):\n\
      \        # Convert each row of bits into its decimal equivalent\n        return\
      \ np.dot(bits, 2 ** np.arange(bits.shape[-1] - 1, -1, -1))\n    \n    def handle_pdu(self,\
      \ msg):\n        # Extract PDU payload\n        meta = pmt.car(msg)  # Metadata\n\
      \        data = pmt.cdr(msg)  # Payload (header + actual data)\n        # #\
      \ payload = np.frombuffer(msg.to_string(), dtype=np.uint8)\n        # print(f\"\
      data: {data}\")\n        # # Map bytes to constellation symbols\n        # bits_per_symbol\
      \ = int(np.log2(len(self.constellation.points())))\n        payload = np.array(pmt.u8vector_elements(data),\
      \ dtype=np.uint8)\n        # print(f\"payload: {payload}\")\n\n        # Convert\
      \ bytes into bitstream\n        # print(f\"data: {type(data)}\")\n        bitstream\
      \ = np.unpackbits(payload)\n        # print(f\"bitstream: {bitstream}\")\n\n\
      \        # Ensure bitstream is a multiple of bits_per_symbol (pad with zeros\
      \ if necessary)\n        extra_bits = len(bitstream) % self.bits_per_symbol\n\
      \        if extra_bits != 0:\n            bitstream = np.pad(bitstream, (0,\
      \ self.bits_per_symbol - extra_bits))\n\n        # Reshape bitstream into symbols\n\
      \        # symbol_indices = np.packbits(bitstream.reshape(-1, self.bits_per_symbol),\
      \ axis=-1).flatten()\n        symbol_indices = self.bits_to_decimal(bitstream.reshape((-1,self.bits_per_symbol)))\n\
      \        # print(f\"just looking: {np.packbits(bitstream.reshape((-1, self.bits_per_symbol)),\
      \ axis=-1)}\")\n        # print(f\"symbol indices: {symbol_indices}\")\n\n \
      \       # Map symbol indices to constellation points\n        # symbols = np.array([self.constellation.map_to_points(int(idx))\
      \ for idx in symbol_indices], dtype=np.complex64)\n        # Allocate array\
      \ for constellation mapping\n        symbols = np.zeros(len(symbol_indices),\
      \ dtype=np.complex64)\n        # print(f\"const points: {self.constellation.points()}\"\
      )\n        # Map symbol indices to constellation points (FIX: Correct function\
      \ call)\n        for index, indice in enumerate(symbol_indices):\n         \
      \   # a = complex(0,0)\n            symbols[index] = self.constellation.map_to_points_v(indice)[0]\n\
      \            # print(index,a)\n\n        # symbols = self.constellation.map_to_points(data)\n\
      \        # print(f\"bits_per_sym: {self.bits_per_symbol}, symbols: {symbols}\"\
      )\n        # Upsample and apply RRC filter\n        upsampled = np.zeros(len(symbols)\
      \ * self.sps, dtype=np.complex64)\n        upsampled[::self.sps] = symbols \
      \ # Insert symbols with spacing\n        self.shaped_data = np.convolve(upsampled,\
      \ self.rrc_taps, mode='full')\n        # print(f\"shape of data: {self.shaped_data.shape}\"\
      )\n        # print(f\"index: {0 if self.keep_front_transients else int(self.sps*self.span/2)}\
      \ {len(self.shaped_data) if self.keep_back_transients else -int(self.sps*self.span/2)}\"\
      )\n        self.shaped_data = self.shaped_data[0 if self.keep_front_transients\
      \ else int(self.sps*self.span/2):len(self.shaped_data) if self.keep_back_transients\
      \ else -int(self.sps*self.span/2)]\n        # print(f\"size of filter: {len(self.rrc_taps)},\
      \ size of output: {len(self.shaped_data)}\")\n        \n        # Tagging: Set\
      \ packet length and update stream tag\n        offset = self.nitems_written(0)\n\
      \        self.add_item_tag(0, offset, gr.pmt.string_to_symbol(\"packet_len\"\
      ), gr.pmt.from_long(len(self.shaped_data)))\n        \n        # # Output modulated\
      \ samples\n        # self.produce(0, len(shaped))\n        # self.output_items[0][:len(shaped)]\
      \ = shaped\n\n    def work(self, input_items, output_items):\n        if self.shaped_data\
      \ is not None:\n            # Output modulated samples\n            output_items[0][:len(self.shaped_data)]\
      \ = self.shaped_data\n            data_size = len(self.shaped_data)\n      \
      \      self.shaped_data = None  # Reset after output\n            return data_size\n\
      \        else:\n            return 0  # No data to output"
    affinity: ''
    alias: ''
    alpha: '.5'
    comment: 'BPSK for MCS0 for header.


      This block takes in a PDU and modulates it

      uses the RRC filter.


      Set if you want to keep the filter transients at the end.

      This may be nice if you want the radio to behave better

      at packet transmition.'
    constellation: constellation
    keep_back_transients: 'False'
    keep_front_transients: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    span: '12'
    sps: sps
  states:
    _io_cache: ('pdu_modulator', 'pdu_modulator', [('constellation', '<gnuradio.digital.digital_python.constellation_bpsk
      object at 0x77fd940ee9b0>'), ('sps', '4'), ('alpha', '0.5'), ('span', '12'),
      ('keep_front_transients', 'False'), ('keep_back_transients', 'False')], [('Data
      in', 'message', 1)], [('0', 'complex', 1)], '\n    Custom GNU Radio block that
      takes in a PDU of bytes, maps them to symbols,\n    applies RRC pulse shaping,
      and outputs a tagged complex stream.\n    ', ['constellation', 'keep_back_transients',
      'keep_front_transients', 'span', 'sps'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [448, 472.0]
    rotation: 0
    state: disabled
- name: epy_block_3_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr, blocks, digital\n\
      from gnuradio.filter import firdes\nimport pmt\n\nclass pdu_modulator(gr.basic_block):\n\
      \    \"\"\"\n    Custom GNU Radio block that takes in a PDU of bytes, maps them\
      \ to symbols,\n    applies RRC pulse shaping, and outputs a tagged complex stream.\n\
      \    \"\"\"\n    def __init__(self, constellation=digital.bpsk_constellation(),\
      \ sps=4, alpha=0.5, span=12,keep_front_transients=False,keep_back_transients=False):\n\
      \        gr.sync_block.__init__(self,\n            name=\"pdu_modulator\",\n\
      \            in_sig=None,\n            out_sig=[np.complex64])\n        \n \
      \       self.constellation = constellation\n        self.sps = sps  # Samples\
      \ per symbol\n        self.span =span\n        self.rrc_taps = firdes.root_raised_cosine(sps,\
      \ sps, 1.0, alpha, span * sps)\n        self.keep_front_transients = keep_front_transients\n\
      \        self.keep_back_transients = keep_back_transients\n        \n      \
      \  self.set_tag_propagation_policy(gr.TPP_DONT)\n        \n        self.bits_per_symbol\
      \ = int(np.log2(len(self.constellation.points())))\n\n        self.message_port_register_in(pmt.intern(\"\
      Data in\"))\n        self.set_msg_handler(pmt.intern(\"Data in\"), self.handle_pdu)\n\
      \        self.shaped_data = None\n\n    @staticmethod\n    def bits_to_decimal(bits):\n\
      \        # Convert each row of bits into its decimal equivalent\n        return\
      \ np.dot(bits, 2 ** np.arange(bits.shape[-1] - 1, -1, -1))\n    \n    def handle_pdu(self,\
      \ msg):\n        # Extract PDU payload\n        meta = pmt.car(msg)  # Metadata\n\
      \        data = pmt.cdr(msg)  # Payload (header + actual data)\n        # #\
      \ payload = np.frombuffer(msg.to_string(), dtype=np.uint8)\n        # print(f\"\
      data: {data}\")\n        # # Map bytes to constellation symbols\n        # bits_per_symbol\
      \ = int(np.log2(len(self.constellation.points())))\n        payload = np.array(pmt.u8vector_elements(data),\
      \ dtype=np.uint8)\n        print(f\"payload: {payload}\")\n\n        # Convert\
      \ bytes into bitstream\n        # print(f\"data: {type(data)}\")\n        bitstream\
      \ = np.unpackbits(payload)\n        print(f\"bitstream: {bitstream}\")\n\n \
      \       # Ensure bitstream is a multiple of bits_per_symbol (pad with zeros\
      \ if necessary)\n        extra_bits = len(bitstream) % self.bits_per_symbol\n\
      \        if extra_bits != 0:\n            bitstream = np.pad(bitstream, (0,\
      \ self.bits_per_symbol - extra_bits))\n\n        # Reshape bitstream into symbols\n\
      \        # symbol_indices = np.packbits(bitstream.reshape(-1, self.bits_per_symbol),\
      \ axis=-1).flatten()\n        symbol_indices = self.bits_to_decimal(bitstream.reshape((-1,self.bits_per_symbol)))\n\
      \        # print(f\"just looking: {np.packbits(bitstream.reshape((-1, self.bits_per_symbol)),\
      \ axis=-1)}\")\n        print(f\"symbol indices: {symbol_indices}\")\n\n   \
      \     # Map symbol indices to constellation points\n        # symbols = np.array([self.constellation.map_to_points(int(idx))\
      \ for idx in symbol_indices], dtype=np.complex64)\n        # Allocate array\
      \ for constellation mapping\n        symbols = np.zeros(len(symbol_indices),\
      \ dtype=np.complex64)\n        print(f\"const points: {self.constellation.points()}\"\
      )\n        # Map symbol indices to constellation points (FIX: Correct function\
      \ call)\n        for index, indice in enumerate(symbol_indices):\n         \
      \   # a = complex(0,0)\n            symbols[index] = self.constellation.map_to_points_v(indice)[0]\n\
      \            # print(index,a)\n\n        # symbols = self.constellation.map_to_points(data)\n\
      \        print(f\"bits_per_sym: {self.bits_per_symbol}, symbols: {symbols}\"\
      )\n        # Upsample and apply RRC filter\n        upsampled = np.zeros(len(symbols)\
      \ * self.sps, dtype=np.complex64)\n        upsampled[::self.sps] = symbols \
      \ # Insert symbols with spacing\n        self.shaped_data = np.convolve(upsampled,\
      \ self.rrc_taps, mode='full')\n        print(f\"shape of data: {self.shaped_data.shape}\"\
      )\n        print(f\"index: {0 if self.keep_front_transients else int(self.sps*self.span/2)}\
      \ {len(self.shaped_data) if self.keep_back_transients else -int(self.sps*self.span/2)}\"\
      )\n        self.shaped_data = self.shaped_data[0 if self.keep_front_transients\
      \ else int(self.sps*self.span/2):len(self.shaped_data) if self.keep_back_transients\
      \ else -int(self.sps*self.span/2)]\n        print(f\"size of filter: {len(self.rrc_taps)},\
      \ size of output: {len(self.shaped_data)}\")\n        \n        # Tagging: Set\
      \ packet length and update stream tag\n        offset = self.nitems_written(0)\n\
      \        self.add_item_tag(0, offset, gr.pmt.string_to_symbol(\"packet_len\"\
      ), gr.pmt.from_long(len(self.shaped_data)))\n        \n        # # Output modulated\
      \ samples\n        # self.produce(0, len(shaped))\n        # self.output_items[0][:len(shaped)]\
      \ = shaped\n\n    def work(self, input_items, output_items):\n        if self.shaped_data\
      \ is not None:\n            # Output modulated samples\n            output_items[0][:len(self.shaped_data)]\
      \ = self.shaped_data\n            data_size = len(self.shaped_data)\n      \
      \      self.shaped_data = None  # Reset after output\n            return data_size\n\
      \        else:\n            return 0  # No data to output"
    affinity: ''
    alias: ''
    alpha: '.5'
    comment: BPSK for MCS0 for payload
    constellation: constellation
    keep_back_transients: 'False'
    keep_front_transients: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    span: '12'
    sps: sps
  states:
    _io_cache: ('pdu_modulator', 'pdu_modulator', [('constellation', '<gnuradio.digital.digital_python.constellation_bpsk
      object at 0x77fd940ee9b0>'), ('sps', '4'), ('alpha', '0.5'), ('span', '12'),
      ('keep_front_transients', 'False'), ('keep_back_transients', 'False')], [('Data
      in', 'message', 1)], [('0', 'complex', 1)], '\n    Custom GNU Radio block that
      takes in a PDU of bytes, maps them to symbols,\n    applies RRC pulse shaping,
      and outputs a tagged complex stream.\n    ', ['constellation', 'keep_back_transients',
      'keep_front_transients', 'span', 'sps'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [448, 144.0]
    rotation: 0
    state: disabled
- name: epy_block_3_0_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr, blocks, digital\n\
      from gnuradio.filter import firdes\nimport pmt\n\nclass pdu_modulator(gr.basic_block):\n\
      \    \"\"\"\n    Custom GNU Radio block that takes in a PDU of bytes, maps them\
      \ to symbols,\n    applies RRC pulse shaping, and outputs a tagged complex stream.\n\
      \    \"\"\"\n    def __init__(self, constellation=digital.bpsk_constellation(),\
      \ sps=4, alpha=0.5, span=12,keep_front_transients=False,keep_back_transients=False):\n\
      \        gr.sync_block.__init__(self,\n            name=\"pdu_modulator\",\n\
      \            in_sig=None,\n            out_sig=[np.complex64])\n        \n \
      \       self.constellation = constellation\n        self.sps = sps  # Samples\
      \ per symbol\n        self.span =span\n        self.rrc_taps = firdes.root_raised_cosine(sps,\
      \ sps, 1.0, alpha, span * sps)\n        self.keep_front_transients = keep_front_transients\n\
      \        self.keep_back_transients = keep_back_transients\n        \n      \
      \  self.set_tag_propagation_policy(gr.TPP_DONT)\n        \n        self.bits_per_symbol\
      \ = int(np.log2(len(self.constellation.points())))\n\n        self.message_port_register_in(pmt.intern(\"\
      Data in\"))\n        self.set_msg_handler(pmt.intern(\"Data in\"), self.handle_pdu)\n\
      \        self.shaped_data = None\n\n    @staticmethod\n    def bits_to_decimal(bits):\n\
      \        # Convert each row of bits into its decimal equivalent\n        return\
      \ np.dot(bits, 2 ** np.arange(bits.shape[-1] - 1, -1, -1))\n    \n    def handle_pdu(self,\
      \ msg):\n        # Extract PDU payload\n        meta = pmt.car(msg)  # Metadata\n\
      \        data = pmt.cdr(msg)  # Payload (header + actual data)\n        # #\
      \ payload = np.frombuffer(msg.to_string(), dtype=np.uint8)\n        # print(f\"\
      data: {data}\")\n        # # Map bytes to constellation symbols\n        # bits_per_symbol\
      \ = int(np.log2(len(self.constellation.points())))\n        payload = np.array(pmt.u8vector_elements(data),\
      \ dtype=np.uint8)\n        print(f\"payload: {payload}\")\n\n        # Convert\
      \ bytes into bitstream\n        # print(f\"data: {type(data)}\")\n        bitstream\
      \ = np.unpackbits(payload)\n        print(f\"bitstream: {bitstream}\")\n\n \
      \       # Ensure bitstream is a multiple of bits_per_symbol (pad with zeros\
      \ if necessary)\n        extra_bits = len(bitstream) % self.bits_per_symbol\n\
      \        if extra_bits != 0:\n            bitstream = np.pad(bitstream, (0,\
      \ self.bits_per_symbol - extra_bits))\n\n        # Reshape bitstream into symbols\n\
      \        # symbol_indices = np.packbits(bitstream.reshape(-1, self.bits_per_symbol),\
      \ axis=-1).flatten()\n        symbol_indices = self.bits_to_decimal(bitstream.reshape((-1,self.bits_per_symbol)))\n\
      \        # print(f\"just looking: {np.packbits(bitstream.reshape((-1, self.bits_per_symbol)),\
      \ axis=-1)}\")\n        print(f\"symbol indices: {symbol_indices}\")\n\n   \
      \     # Map symbol indices to constellation points\n        # symbols = np.array([self.constellation.map_to_points(int(idx))\
      \ for idx in symbol_indices], dtype=np.complex64)\n        # Allocate array\
      \ for constellation mapping\n        symbols = np.zeros(len(symbol_indices),\
      \ dtype=np.complex64)\n        print(f\"const points: {self.constellation.points()}\"\
      )\n        # Map symbol indices to constellation points (FIX: Correct function\
      \ call)\n        for index, indice in enumerate(symbol_indices):\n         \
      \   # a = complex(0,0)\n            symbols[index] = self.constellation.map_to_points_v(indice)[0]\n\
      \            # print(index,a)\n\n        # symbols = self.constellation.map_to_points(data)\n\
      \        print(f\"bits_per_sym: {self.bits_per_symbol}, symbols: {symbols}\"\
      )\n        # Upsample and apply RRC filter\n        upsampled = np.zeros(len(symbols)\
      \ * self.sps, dtype=np.complex64)\n        upsampled[::self.sps] = symbols \
      \ # Insert symbols with spacing\n        self.shaped_data = np.convolve(upsampled,\
      \ self.rrc_taps, mode='full')\n        print(f\"shape of data: {self.shaped_data.shape}\"\
      )\n        print(f\"index: {0 if self.keep_front_transients else int(self.sps*self.span/2)}\
      \ {len(self.shaped_data) if self.keep_back_transients else -int(self.sps*self.span/2)}\"\
      )\n        self.shaped_data = self.shaped_data[0 if self.keep_front_transients\
      \ else int(self.sps*self.span/2):len(self.shaped_data) if self.keep_back_transients\
      \ else -int(self.sps*self.span/2)]\n        print(f\"size of filter: {len(self.rrc_taps)},\
      \ size of output: {len(self.shaped_data)}\")\n        \n        # Tagging: Set\
      \ packet length and update stream tag\n        offset = self.nitems_written(0)\n\
      \        self.add_item_tag(0, offset, gr.pmt.string_to_symbol(\"packet_len\"\
      ), gr.pmt.from_long(len(self.shaped_data)))\n        \n        # # Output modulated\
      \ samples\n        # self.produce(0, len(shaped))\n        # self.output_items[0][:len(shaped)]\
      \ = shaped\n\n    def work(self, input_items, output_items):\n        if self.shaped_data\
      \ is not None:\n            # Output modulated samples\n            output_items[0][:len(self.shaped_data)]\
      \ = self.shaped_data\n            data_size = len(self.shaped_data)\n      \
      \      self.shaped_data = None  # Reset after output\n            return data_size\n\
      \        else:\n            return 0  # No data to output"
    affinity: ''
    alias: ''
    alpha: '.5'
    comment: QPSK for MCS1 for payload.
    constellation: constellation1
    keep_back_transients: 'False'
    keep_front_transients: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    span: '12'
    sps: sps
  states:
    _io_cache: ('pdu_modulator', 'pdu_modulator', [('constellation', '<gnuradio.digital.digital_python.constellation_bpsk
      object at 0x77fd95ddad70>'), ('sps', '4'), ('alpha', '0.5'), ('span', '12'),
      ('keep_front_transients', 'False'), ('keep_back_transients', 'False')], [('Data
      in', 'message', 1)], [('0', 'complex', 1)], '\n    Custom GNU Radio block that
      takes in a PDU of bytes, maps them to symbols,\n    applies RRC pulse shaping,
      and outputs a tagged complex stream.\n    ', ['constellation', 'keep_back_transients',
      'keep_front_transients', 'span', 'sps'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [448, 304.0]
    rotation: 0
    state: disabled
- name: iio_pluto_sink_0_0
  id: iio_pluto_sink
  parameters:
    affinity: ''
    alias: ''
    attenuation1: tx_attenuation
    bandwidth: int(samp_rate)
    buffer_size: '32768'
    comment: ''
    cyclic: 'False'
    filter: ''
    filter_source: '''Auto'''
    fpass: '0'
    frequency: int(center_freq)
    fstop: '0'
    len_tag_key: ''
    samplerate: int(samp_rate)
    type: fc32
    uri: 192.168.2.1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [880, 1004.0]
    rotation: 0
    state: disabled
- name: iio_pluto_source_0
  id: iio_pluto_source
  parameters:
    affinity: ''
    alias: ''
    bandwidth: '20000000'
    bbdc: 'True'
    buffer_size: '32768'
    comment: ''
    filter: ''
    filter_source: '''Auto'''
    fpass: '0'
    frequency: int(center_freq)
    fstop: '0'
    gain1: '''slow_attack'''
    len_tag_key: packet_len
    manual_gain1: '64'
    maxoutbuf: '0'
    minoutbuf: '0'
    quadrature: 'True'
    rfdc: 'True'
    samplerate: int(samp_rate)
    type: fc32
    uri: ''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [128, 1540.0]
    rotation: 0
    state: disabled
- name: import_0
  id: import
  parameters:
    alias: ''
    comment: ''
    imports: import math
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 120.0]
    rotation: 0
    state: enabled
- name: note_2
  id: note
  parameters:
    alias: ''
    comment: ''
    note: Read data from a file as data to TX
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [136, 992.0]
    rotation: 0
    state: disabled
- name: note_3
  id: note
  parameters:
    alias: ''
    comment: ''
    note: Preamble (010101010101...)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1384, 16.0]
    rotation: 0
    state: enabled
- name: qtgui_const_sink_x_0_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"red"'
    color2: '"red"'
    color3: '"red"'
    color4: '"red"'
    color5: '"red"'
    color6: '"red"'
    color7: '"red"'
    color8: '"red"'
    color9: '"red"'
    comment: makes most sense if "Output Samples/Symbol" is 1
    grid: 'False'
    gui_hint: 17,0
    label1: after Symbol Sync
    label10: ''
    label2: after Costas
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '""'
    nconnections: '2'
    size: '1024'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 1960.0]
    rotation: 0
    state: disabled
- name: qtgui_eye_sink_x_0
  id: qtgui_eye_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: blue
    color2: blue
    color3: blue
    color4: blue
    color5: blue
    color6: blue
    color7: blue
    color8: blue
    color9: blue
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: 'qtgui_tab@0 '
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    nconnections: '1'
    samp_per_symbol: sps
    size: '1024'
    srate: samp_rate
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1144, 1128.0]
    rotation: 0
    state: disabled
- name: qtgui_eye_sink_x_0_0_0
  id: qtgui_eye_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: blue
    color2: blue
    color3: blue
    color4: blue
    color5: blue
    color6: blue
    color7: blue
    color8: blue
    color9: blue
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: 16,0
    label1: Eye Diagram after Costas Re
    label10: Signal 10
    label2: Eye Diagram after Costas  Im
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '0'
    marker10: '-1'
    marker2: '0'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    nconnections: '1'
    samp_per_symbol: sps
    size: '1024'
    srate: samp_rate/sps*output_sps
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '2'
    ymin: '-2'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1056, 1832.0]
    rotation: 0
    state: disabled
- name: qtgui_freq_sink_x_1
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    average: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    ctrlpanel: 'False'
    fc: '0'
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: 1,0
    label: Relative Gain
    label1: Transmit
    label10: ''''''
    label2: ''''''
    label3: ''''''
    label4: ''''''
    label5: ''''''
    label6: ''''''
    label7: ''''''
    label8: ''''''
    label9: ''''''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '""'
    nconnections: '1'
    norm_window: 'False'
    showports: 'False'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: window.WIN_BLACKMAN_hARRIS
    ymax: '10'
    ymin: '-140'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1144, 1040.0]
    rotation: 0
    state: disabled
- name: qtgui_tab
  id: qtgui_tab_widget
  parameters:
    alias: ''
    comment: ''
    gui_hint: ''
    label0: normal
    label1: debug
    label10: Tab 10
    label11: Tab 11
    label12: Tab 12
    label13: Tab 13
    label14: Tab 14
    label15: Tab 15
    label16: Tab 16
    label17: Tab 17
    label18: Tab 18
    label19: Tab 19
    label2: Tab 2
    label3: Tab 3
    label4: Tab 4
    label5: Tab 5
    label6: Tab 6
    label7: Tab 7
    label8: Tab 8
    label9: Tab 9
    num_tabs: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1120, 8.0]
    rotation: 0
    state: disabled
- name: qtgui_time_raster_sink_x_0
  id: qtgui_time_raster_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    axislabels: 'True'
    color1: '1'
    color10: '0'
    color2: '0'
    color3: '0'
    color4: '0'
    color5: '0'
    color6: '0'
    color7: '0'
    color8: '0'
    color9: '0'
    comment: ''
    grid: 'False'
    gui_hint: 0,0,1,1
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    mult: '[]'
    name: '"Pre-decoder"'
    ncols: '148'
    nconnections: '1'
    nrows: '100'
    offset: '[]'
    samp_rate: samp_rate
    type: byte
    update_time: '0.10'
    x_end_value: '0.0'
    x_label: '""'
    x_start_value: '0.0'
    y_end_value: '0.0'
    y_label: '""'
    y_start_value: '0.0'
    zmax: '1'
    zmin: '-1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [496, 860.0]
    rotation: 0
    state: enabled
- name: qtgui_time_raster_sink_x_0_0
  id: qtgui_time_raster_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    axislabels: 'True'
    color1: '1'
    color10: '0'
    color2: '0'
    color3: '0'
    color4: '0'
    color5: '0'
    color6: '0'
    color7: '0'
    color8: '0'
    color9: '0'
    comment: ''
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    mult: '[]'
    name: '"Post-decoder"'
    ncols: '148'
    nconnections: '1'
    nrows: '100'
    offset: '[]'
    samp_rate: samp_rate
    type: byte
    update_time: '0.10'
    x_end_value: '0.0'
    x_label: '""'
    x_start_value: '0.0'
    y_end_value: '0.0'
    y_label: '""'
    y_start_value: '0.0'
    zmax: '1'
    zmin: '-1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [800, 700.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'True'
    entags: 'True'
    grid: 'False'
    gui_hint: qtgui_tab@0 :0,0
    label1: Transmit re
    label10: Signal 10
    label2: Transmit im
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '0'
    marker10: '-1'
    marker2: '0'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: '624'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_TAG
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '"packet_len"'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1.2'
    ymin: '-1.2'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1152, 928.0]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_0_0_0_0_0_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: 18,0
    label1: Receive after Costas Re
    label10: Signal 10
    label2: Receive after Costas Im
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '0'
    marker10: '-1'
    marker2: '0'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: '100'
    srate: samp_rate/sps*output_sps
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '2'
    ymin: '-2'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1056, 2064.0]
    rotation: 0
    state: disabled
- name: virtual_sink_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: header
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [720, 504.0]
    rotation: 0
    state: disabled
- name: virtual_sink_1
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: transmit_data
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1376, 272.0]
    rotation: 0
    state: disabled
- name: virtual_source_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: transmit_data
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [120, 1144.0]
    rotation: 0
    state: disabled
- name: virtual_source_0_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: header
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [912, 192.0]
    rotation: 0
    state: disabled
- name: zeromq_rep_msg_sink_0
  id: zeromq_rep_msg_sink
  parameters:
    address: 192.168.0.50
    affinity: ''
    alias: ''
    bind: 'True'
    comment: ''
    timeout: '100'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1096, 1368.0]
    rotation: 0
    state: disabled
- name: zeromq_req_msg_source_0
  id: zeromq_req_msg_source
  parameters:
    address: ''
    affinity: ''
    alias: ''
    bind: 'False'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    timeout: '100'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [840, 1368.0]
    rotation: 0
    state: disabled
- name: zeromq_sub_msg_source_0
  id: zeromq_sub_msg_source
  parameters:
    address: tcp://127.0.0.1:5555
    affinity: ''
    alias: ''
    bind: 'False'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    timeout: '100'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [16, 216.0]
    rotation: 0
    state: disabled

connections:
- [analog_agc_xx_1, '0', digital_fll_band_edge_cc_0, '0']
- [analog_random_source_x_0, '0', blocks_stream_mux_0, '1']
- [analog_sig_source_x_0, '0', blocks_multiply_xx_0, '1']
- [blocks_multiply_const_vxx_0, '0', blocks_multiply_xx_0, '0']
- [blocks_multiply_const_vxx_0, '0', iio_pluto_sink_0_0, '0']
- [blocks_multiply_const_vxx_0, '0', qtgui_eye_sink_x_0, '0']
- [blocks_multiply_const_vxx_0, '0', qtgui_freq_sink_x_1, '0']
- [blocks_multiply_const_vxx_0, '0', qtgui_time_sink_x_0, '0']
- [blocks_multiply_xx_0, '0', analog_agc_xx_1, '0']
- [blocks_selector_1, '0', blocks_tagged_stream_mux_0_0, '1']
- [blocks_skiphead_0, '0', digital_symbol_sync_xx_0, '0']
- [blocks_stream_mux_0, '0', epy_block_1, '0']
- [blocks_stream_mux_0, '0', qtgui_time_raster_sink_x_0, '0']
- [blocks_tagged_stream_mux_0_0, '0', blocks_tag_debug_0_0_1_0, '0']
- [blocks_tagged_stream_mux_0_0, '0', virtual_sink_1, '0']
- [blocks_vector_source_x_0, '0', blocks_stream_mux_0, '0']
- [digital_constellation_decoder_cb_0, '0', blocks_unpacked_to_packed_xx_0, '0']
- [digital_costas_loop_cc_0, '0', digital_constellation_decoder_cb_0, '0']
- [digital_costas_loop_cc_0, '0', qtgui_const_sink_x_0_0, '1']
- [digital_costas_loop_cc_0, '0', qtgui_eye_sink_x_0_0_0, '0']
- [digital_costas_loop_cc_0, '0', qtgui_time_sink_x_0_0_0_0_0_0, '0']
- [digital_fll_band_edge_cc_0, '0', blocks_skiphead_0, '0']
- [digital_symbol_sync_xx_0, '0', digital_costas_loop_cc_0, '0']
- [digital_symbol_sync_xx_0, '0', qtgui_const_sink_x_0_0, '0']
- [epy_block_0, data_out, epy_block_3_0, Data in]
- [epy_block_0, data_out, epy_block_3_0_0, Data in]
- [epy_block_0, header_out, epy_block_3, Data in]
- [epy_block_0, mcs_out, blocks_selector_1, iindex]
- [epy_block_1, '0', qtgui_time_raster_sink_x_0_0, '0']
- [epy_block_3, '0', virtual_sink_0, '0']
- [epy_block_3_0, '0', blocks_selector_1, '0']
- [epy_block_3_0_0, '0', blocks_selector_1, '1']
- [iio_pluto_source_0, '0', analog_agc_xx_1, '0']
- [virtual_source_0, '0', blocks_multiply_const_vxx_0, '0']
- [virtual_source_0, '0', blocks_multiply_xx_0, '0']
- [virtual_source_0, '0', qtgui_eye_sink_x_0, '0']
- [virtual_source_0, '0', qtgui_freq_sink_x_1, '0']
- [virtual_source_0, '0', qtgui_time_sink_x_0, '0']
- [virtual_source_0_0, '0', blocks_tagged_stream_mux_0_0, '0']
- [zeromq_sub_msg_source_0, out, epy_block_0, pdu_in]

metadata:
  file_format: 1
  grc_version: 3.10.10.0
